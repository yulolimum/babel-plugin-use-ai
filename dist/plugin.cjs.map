{"version":3,"sources":["../src/prompt-builder.ts","../src/code-generator.ts","../src/cache.ts","../src/plugin.ts"],"names":["createOpenRouter","generateText","path","fs","crypto","require","createRequire"],"mappings":";;;;;;;;;;;;;;;;;;;;AAOO,SAAS,WAAA,CACd,YAAA,EACA,QAAA,GAAqB,EAAC,EACd;AACR,EAAA,MAAM,UAAA,GAAa,CAAA;;AAAA,EAEnB,YAAY;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,EAWZ,SAAS,YAAA,GAAe,CAAA,yBAAA,EAA4B,QAAA,CAAS,YAAY,KAAK,EAAE;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAAA,CAAA;AAShF,EAAA,OAAO,UAAA;AACT;AC7BA,eAAsB,qBACpB,MAAA,EACA,QAAA,GAAqB,EAAC,EACtB,MAAA,EACA,OACA,iBAAA,EACiB;AACjB,EAAA,IAAI,SAAS,iBAAA,EAAmB;AAC9B,IAAA,MAAM,MAAA,GAAS,KAAA,CAAM,GAAA,CAAI,iBAAA,EAAmB,QAAQ,CAAA;AACpD,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,OAAO,MAAA;AAAA,IACT;AAAA,EACF;AAEA,EAAA,MAAM,GAAA,GAAM,MAAA,IAAU,OAAA,CAAQ,GAAA,CAAI,kBAAA;AAClC,EAAA,IAAI,CAAC,GAAA,EAAK;AACR,IAAA,MAAM,IAAI,MAAM,gCAAgC,CAAA;AAAA,EAClD;AAEA,EAAA,MAAM,UAAA,GAAaA,8BAAA,CAAiB,EAAE,MAAA,EAAQ,KAAK,CAAA;AACnD,EAAA,MAAM,KAAA,GAAQ,UAAA,CAAW,QAAA,CAAS,KAAA,IAAS,oBAAoB,CAAA;AAE/D,EAAA,MAAM,OAAA,GAA+B;AAAA,IACnC,WAAA,EAAa,SAAS,WAAA,IAAe;AAAA,GACvC;AAEA,EAAA,IAAI,QAAA,CAAS,SAAS,MAAA,EAAW;AAC/B,IAAA,OAAA,CAAQ,OAAO,QAAA,CAAS,IAAA;AAAA,EAC1B;AAEA,EAAA,IAAI;AACF,IAAA,MAAM,EAAE,IAAA,EAAK,GAAI,MAAMC,eAAA,CAAa;AAAA,MAClC,KAAA;AAAA,MACA,MAAA;AAAA,MACA,GAAG;AAAA,KACJ,CAAA;AAED,IAAA,MAAM,aAAA,GAAgB,KAAK,IAAA,EAAK;AAEhC,IAAA,IAAI,SAAS,iBAAA,EAAmB;AAC9B,MAAA,KAAA,CAAM,GAAA,CAAI,iBAAA,EAAmB,QAAA,EAAU,aAAa,CAAA;AAAA,IACtD;AAEA,IAAA,OAAO,aAAA;AAAA,EACT,SAAS,KAAA,EAAO;AACd,IAAA,MAAM,KAAA;AAAA,EACR;AACF;ACpCO,IAAM,gBAAN,MAAoB;AAAA,EAIzB,WAAA,CAAY,gBAAwB,gBAAA,EAAkB;AACpD,IAAA,IAAA,CAAK,YAAYC,qBAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,GAAA,IAAO,aAAa,CAAA;AAC1D,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAK,SAAA,EAAU;AAAA,EAC9B;AAAA,EAEQ,SAAA,GAAmB;AACzB,IAAA,IAAI;AACF,MAAA,IAAIC,mBAAA,CAAG,UAAA,CAAW,IAAA,CAAK,SAAS,CAAA,EAAG;AACjC,QAAA,MAAM,IAAA,GAAOA,mBAAA,CAAG,YAAA,CAAa,IAAA,CAAK,WAAW,OAAO,CAAA;AACpD,QAAA,OAAO,IAAA,CAAK,MAAM,IAAI,CAAA;AAAA,MACxB;AAAA,IACF,SAAS,KAAA,EAAO;AAAA,IAChB;AACA,IAAA,OAAO,EAAC;AAAA,EACV;AAAA,EAEQ,SAAA,GAAkB;AACxB,IAAA,IAAI;AACF,MAAAA,mBAAA,CAAG,aAAA,CAAc,IAAA,CAAK,SAAA,EAAW,IAAA,CAAK,SAAA,CAAU,KAAK,KAAA,EAAO,IAAA,EAAM,CAAC,CAAA,EAAG,OAAO,CAAA;AAAA,IAC/E,SAAS,KAAA,EAAO;AAAA,IAChB;AAAA,EACF;AAAA,EAEQ,WAAA,CAAY,WAAmB,QAAA,EAA4B;AACjE,IAAA,MAAM,OAAO,IAAA,CAAK,SAAA,CAAU,EAAE,SAAA,EAAW,UAAU,CAAA;AACnD,IAAA,OAAOC,uBAAA,CAAO,WAAW,QAAQ,CAAA,CAAE,OAAO,IAAI,CAAA,CAAE,OAAO,KAAK,CAAA;AAAA,EAC9D;AAAA,EAEA,GAAA,CAAI,WAAmB,QAAA,EAAmC;AACxD,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,WAAA,CAAY,SAAA,EAAW,QAAQ,CAAA;AAChD,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA;AAE5B,IAAA,IAAI,KAAA,EAAO;AACT,MAAA,OAAO,KAAA,CAAM,aAAA;AAAA,IACf;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,GAAA,CAAI,SAAA,EAAmB,QAAA,EAAoB,aAAA,EAA6B;AACtE,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,WAAA,CAAY,SAAA,EAAW,QAAQ,CAAA;AAChD,IAAA,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA,GAAI;AAAA,MAChB,SAAA;AAAA,MACA,QAAA;AAAA,MACA,aAAA;AAAA,MACA,SAAA,EAAW,KAAK,GAAA;AAAI,KACtB;AACA,IAAA,IAAA,CAAK,SAAA,EAAU;AAAA,EACjB;AAAA,EAEA,KAAA,GAAc;AACZ,IAAA,IAAA,CAAK,QAAQ,EAAC;AACd,IAAA,IAAA,CAAK,SAAA,EAAU;AAAA,EACjB;AAAA,EAEA,IAAA,GAAe;AACb,IAAA,OAAO,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,KAAK,CAAA,CAAE,MAAA;AAAA,EACjC;AACF,CAAA;ACtEA,IAAMC,QAAAA,GAAUC,sBAAA,CAAc,4PAAe,CAAA;AAQ9B,SAAR,gBAAA,CACL,SAAA,EACA,OAAA,GAAyB,EAAC,EAC1B;AACA,EAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,MAAA,IAAU,OAAA,CAAQ,GAAA,CAAI,kBAAA;AAC7C,EAAA,IAAI,CAAC,MAAA,EAAQ;AACX,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AAEA,EAAA,MAAM,aAAA,GAAgB;AAAA,IACpB,MAAA;AAAA,IACA,KAAA,EAAO,QAAQ,KAAA,IAAS,oBAAA;AAAA,IACxB,WAAA,EAAa,QAAQ,WAAA,IAAe;AAAA,GACtC;AAEA,EAAA,MAAM,KAAA,GAAQ,IAAI,aAAA,EAAc;AAChC,EAAA,MAAM,oBAAqC,EAAC;AAE5C,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,qBAAA;AAAA,IACN,OAAA,EAAS;AAAA,MACP,oBAAoBJ,KAAAA,EAAuC;AACzD,QAAA,MAAM,OAAOA,KAAAA,CAAK,IAAA;AAClB,QAAA,MAAM,OAAO,IAAA,CAAK,IAAA;AAElB,QAAA,IAAI,CAAC,IAAA,IAAS,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,CAAA,KAAM,CAAC,IAAA,CAAK,UAAA,IAAc,IAAA,CAAK,UAAA,CAAW,MAAA,KAAW,CAAA,CAAA,EAAK;AAC3F,UAAA;AAAA,QACF;AAEA,QAAA,IAAI,cAAA,GAAiB,KAAA;AACrB,QAAA,IAAI,KAAK,UAAA,EAAY;AACnB,UAAA,KAAA,MAAW,SAAA,IAAa,KAAK,UAAA,EAAY;AACvC,YAAA,IAAK,SAAA,CAAkB,KAAA,CAAM,KAAA,KAAU,QAAA,EAAU;AAC/C,cAAA,cAAA,GAAiB,IAAA;AACjB,cAAA;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,QAAA,IAAI,CAAC,cAAA,EAAgB;AACnB,UAAA;AAAA,QACF;AAEA,QAAA,MAAM,SAAA,GAAY,mBAAA;AAAA,UAChBA,KAAAA;AAAA,UACA,aAAA;AAAA,UACA;AAAA,SACF;AACA,QAAA,iBAAA,CAAkB,KAAK,SAAS,CAAA;AAAA,MAClC;AAAA,KACF;AAAA,IACA,IAAA,GAAO;AACL,MAAA,OAAO,OAAA,CAAQ,IAAI,iBAAiB,CAAA;AAAA,IACtC;AAAA,GACF;AACF;AAuBA,SAAS,6BAA6B,IAAA,EAAkC;AACtE,EAAA,IAAI,CAAC,QAAQ,CAAC,IAAA,CAAK,cAAc,IAAA,CAAK,UAAA,CAAW,WAAW,CAAA,EAAG;AAC7D,IAAA,OAAO,EAAC;AAAA,EACV;AAEA,EAAA,IAAI,cAAA,GAAsB,IAAA;AAC1B,EAAA,KAAA,MAAW,SAAA,IAAa,KAAK,UAAA,EAAY;AACvC,IAAA,IAAK,SAAA,CAAkB,KAAA,CAAM,KAAA,KAAU,QAAA,EAAU;AAC/C,MAAA,cAAA,GAAiB,SAAA;AACjB,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,IAAI,CAAC,cAAA,EAAgB;AACnB,IAAA,OAAO,EAAC;AAAA,EACV;AAEA,EAAA,MAAM,mBAAmB,cAAA,CAAe,gBAAA;AACxC,EAAA,IAAI,CAAC,gBAAA,IAAoB,gBAAA,CAAiB,MAAA,KAAW,CAAA,EAAG;AACtD,IAAA,OAAO,EAAC;AAAA,EACV;AAEA,EAAA,MAAM,OAAA,GAAU,iBAAiB,CAAC,CAAA;AAClC,EAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,KAAA,CAAM,IAAA,EAAK;AACvC,EAAA,MAAM,WAAqB,EAAC;AAC5B,EAAA,MAAM,KAAA,GAAQ,WAAA,CAAY,KAAA,CAAM,GAAG,CAAA,CAAE,IAAI,CAAC,CAAA,KAAc,CAAA,CAAE,IAAA,EAAM,CAAA;AAEhE,EAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,IAAA,MAAM,CAAC,GAAA,EAAK,KAAK,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,CAAI,CAAC,CAAA,KAAc,CAAA,CAAE,MAAM,CAAA;AAChE,IAAA,IAAI,GAAA,KAAQ,aAAA,IAAiB,GAAA,KAAQ,MAAA,EAAQ;AAC3C,MAAA,QAAA,CAAS,GAAqB,IAAI,KAAA,CAAM,MAAA,CAAO,KAAK,CAAC,CAAA,GAChD,KAAA,GACD,UAAA,CAAW,KAAK,CAAA;AAAA,IACtB,CAAA,MAAA,IAAW,QAAQ,cAAA,EAAgB;AACjC,MAAA,QAAA,CAAS,YAAA,GAAe,KAAA,CAAM,OAAA,CAAQ,cAAA,EAAgB,EAAE,CAAA;AAAA,IAC1D,CAAA,MAAA,IAAW,QAAQ,OAAA,EAAS;AAC1B,MAAA,QAAA,CAAS,KAAA,GAAQ,KAAA;AAAA,IACnB;AAAA,EACF;AAEA,EAAA,OAAO,QAAA;AACT;AAEA,eAAe,mBAAA,CACbA,KAAAA,EACA,aAAA,EACA,KAAA,EACe;AACf,EAAA,MAAM,OAAOA,KAAAA,CAAK,IAAA;AAClB,EAAA,MAAM,QAAA,GAAW,4BAAA,CAA6B,IAAA,CAAK,IAAI,CAAA;AAEvD,EAAA,MAAM,UAAA,GAAaA,MAAK,SAAA,EAAU;AAClC,EAAA,MAAM,cAAA,GAAiB,UAAA,CAAW,KAAA,CAAM,QAAQ,CAAA;AAChD,EAAA,MAAM,oBAAoB,cAAA,GAAiB,cAAA,CAAe,CAAC,CAAA,CAAE,MAAK,GAAI,UAAA;AAEtE,EAAA,MAAM,cAAA,GAA2B;AAAA,IAC/B,GAAG,QAAA;AAAA,IACH,KAAA,EAAO,QAAA,CAAS,KAAA,IAAS,aAAA,CAAc,KAAA;AAAA,IACvC,WAAA,EAAa,QAAA,CAAS,WAAA,IAAe,aAAA,CAAc;AAAA,GACrD;AAEA,EAAA,MAAM,MAAA,GAAS,WAAA,CAAY,iBAAA,EAAmB,cAAc,CAAA;AAE5D,EAAA,IAAI;AACF,IAAA,IAAI,gBAAgB,MAAM,oBAAA;AAAA,MACxB,MAAA;AAAA,MACA,cAAA;AAAA,MACA,aAAA,CAAc,MAAA;AAAA,MACd,KAAA;AAAA,MACA;AAAA,KACF;AAEA,IAAA,aAAA,GAAgB,cAAc,OAAA,CAAQ,yCAAA,EAA2C,EAAE,CAAA,CAAE,OAAA,CAAQ,WAAW,EAAE,CAAA;AAE1G,IAAA,MAAM,OAAA,GAAU,eAAe,aAAa,CAAA;AAC5C,IAAA,IAAA,CAAK,KAAK,IAAA,GAAO,OAAA;AACjB,IAAA,IAAA,CAAK,IAAA,CAAK,aAAa,EAAC;AAAA,EAC1B,SAAS,KAAA,EAAO;AACd,IAAA,MAAM,KAAA;AAAA,EACR;AACF;AAEA,SAAS,eAAe,UAAA,EAAmC;AACzD,EAAA,MAAM,MAAA,GAASG,SAAQ,eAAe,CAAA;AAEtC,EAAA,IAAI;AACF,IAAA,MAAM,GAAA,GAAM,MAAA,CAAO,KAAA,CAAM,CAAA,cAAA,EAAiB,UAAU,CAAA,GAAA,CAAA,EAAO;AAAA,MACzD,UAAA,EAAY,QAAA;AAAA,MACZ,OAAA,EAAS,CAAC,YAAY;AAAA,KACvB,CAAA;AAED,IAAA,MAAM,YAAA,GAAe,GAAA,CAAI,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA,CAAE,UAAA;AACzC,IAAA,MAAM,iBAAiB,YAAA,CAAa,IAAA;AAEpC,IAAA,OAAO,cAAA,CAAe,IAAA;AAAA,EACxB,SAAS,KAAA,EAAO;AACd,IAAA,MAAM,KAAA;AAAA,EACR;AACF","file":"plugin.cjs","sourcesContent":["export interface Metadata {\n  temperature?: number\n  seed?: number\n  instructions?: string\n  model?: string\n}\n\nexport function buildPrompt(\n  functionCode: string,\n  metadata: Metadata = {}\n): string {\n  const basePrompt = `You are a code generation assistant. Generate a function body for the following function:\n\n${functionCode}\n\nRequirements:\n- Implement the function according to its name and type signature\n- The function name describes what it should do\n- Must return the correct type\n- No side effects unless implied by the name\n- Valid TypeScript/JavaScript\n- No comments in the generated code\n- No console.log or debugging statements\n\n${metadata.instructions ? `Additional instructions: ${metadata.instructions}` : ''}\n\nGenerate ONLY the function body code (no outer braces, no function declaration).\nExample:\nfor (let i = 0; i < arr.length; i++) {\n  // code here\n}\nreturn result`\n\n  return basePrompt\n}\n\nexport function extractMetadata(leadingComments: any[] | undefined): Metadata {\n  if (!leadingComments || leadingComments.length === 0) {\n    return {}\n  }\n\n  const lastComment = leadingComments[leadingComments.length - 1]\n  const commentText = lastComment.value\n\n  const metadataMatch = commentText.match(/@ai\\s+(.+)/)\n  if (!metadataMatch) {\n    return {}\n  }\n\n  const metadata: Metadata = {}\n  const pairs = metadataMatch[1].split(',').map((s: string) => s.trim())\n\n  for (const pair of pairs) {\n    const [key, value] = pair.split('=').map((s: string) => s.trim())\n    if (key === 'temperature' || key === 'seed') {\n      metadata[key as keyof Metadata] = isNaN(Number(value))\n        ? (value as any)\n        : parseFloat(value)\n    } else if (key === 'instructions') {\n      metadata.instructions = value.replace(/^[\"']|[\"']$/g, '')\n    } else if (key === 'model') {\n      metadata.model = value\n    }\n  }\n\n  return metadata\n}\n","import { generateText } from 'ai'\nimport { createOpenRouter } from '@openrouter/ai-sdk-provider'\nimport type { Metadata } from './prompt-builder'\nimport type { FunctionCache } from './cache'\n\nexport async function generateFunctionBody(\n  prompt: string,\n  metadata: Metadata = {},\n  apiKey?: string,\n  cache?: FunctionCache,\n  functionSignature?: string\n): Promise<string> {\n  if (cache && functionSignature) {\n    const cached = cache.get(functionSignature, metadata)\n    if (cached) {\n      return cached\n    }\n  }\n\n  const key = apiKey || process.env.OPENROUTER_API_KEY\n  if (!key) {\n    throw new Error('OpenRouter API key is required')\n  }\n\n  const openrouter = createOpenRouter({ apiKey: key })\n  const model = openrouter(metadata.model || 'openai/gpt-4-turbo')\n\n  const options: Record<string, any> = {\n    temperature: metadata.temperature ?? 0.7,\n  }\n\n  if (metadata.seed !== undefined) {\n    options.seed = metadata.seed\n  }\n\n  try {\n    const { text } = await generateText({\n      model,\n      prompt,\n      ...options,\n    })\n\n    const generatedCode = text.trim()\n    \n    if (cache && functionSignature) {\n      cache.set(functionSignature, metadata, generatedCode)\n    }\n\n    return generatedCode\n  } catch (error) {\n    throw error\n  }\n}\n","import fs from 'fs'\nimport path from 'path'\nimport crypto from 'crypto'\nimport type { Metadata } from './prompt-builder'\n\nexport interface CacheEntry {\n  signature: string\n  metadata: Metadata\n  generatedCode: string\n  timestamp: number\n}\n\nexport interface Cache {\n  [key: string]: CacheEntry\n}\n\nexport class FunctionCache {\n  private cachePath: string\n  private cache: Cache\n\n  constructor(cacheFilePath: string = '.ai-cache.json') {\n    this.cachePath = path.resolve(process.cwd(), cacheFilePath)\n    this.cache = this.loadCache()\n  }\n\n  private loadCache(): Cache {\n    try {\n      if (fs.existsSync(this.cachePath)) {\n        const data = fs.readFileSync(this.cachePath, 'utf-8')\n        return JSON.parse(data)\n      }\n    } catch (error) {\n    }\n    return {}\n  }\n\n  private saveCache(): void {\n    try {\n      fs.writeFileSync(this.cachePath, JSON.stringify(this.cache, null, 2), 'utf-8')\n    } catch (error) {\n    }\n  }\n\n  private generateKey(signature: string, metadata: Metadata): string {\n    const data = JSON.stringify({ signature, metadata })\n    return crypto.createHash('sha256').update(data).digest('hex')\n  }\n\n  get(signature: string, metadata: Metadata): string | null {\n    const key = this.generateKey(signature, metadata)\n    const entry = this.cache[key]\n    \n    if (entry) {\n      return entry.generatedCode\n    }\n    \n    return null\n  }\n\n  set(signature: string, metadata: Metadata, generatedCode: string): void {\n    const key = this.generateKey(signature, metadata)\n    this.cache[key] = {\n      signature,\n      metadata,\n      generatedCode,\n      timestamp: Date.now(),\n    }\n    this.saveCache()\n  }\n\n  clear(): void {\n    this.cache = {}\n    this.saveCache()\n  }\n\n  size(): number {\n    return Object.keys(this.cache).length\n  }\n}\n","import * as t from '@babel/types'\nimport type { NodePath } from '@babel/traverse'\nimport { buildPrompt, extractMetadata } from './prompt-builder'\nimport { generateFunctionBody } from './code-generator'\nimport type { Metadata } from './prompt-builder'\nimport { FunctionCache } from './cache'\nimport { createRequire } from 'module'\n\nconst require = createRequire(import.meta.url)\n\nexport interface PluginOptions {\n  apiKey?: string\n  model?: string\n  temperature?: number\n}\n\nexport default function babelPluginUseAi(\n  _babelApi: any,\n  options: PluginOptions = {}\n) {\n  const apiKey = options.apiKey || process.env.OPENROUTER_API_KEY\n  if (!apiKey) {\n    throw new Error(\n      'babel-plugin-use-ai: apiKey is required. Pass it via options or set OPENROUTER_API_KEY environment variable.'\n    )\n  }\n\n  const pluginOptions = {\n    apiKey,\n    model: options.model || 'openai/gpt-4-turbo',\n    temperature: options.temperature ?? 0.7,\n  }\n\n  const cache = new FunctionCache()\n  const pendingOperations: Promise<void>[] = []\n\n  return {\n    name: 'babel-plugin-use-ai',\n    visitor: {\n      FunctionDeclaration(path: NodePath<t.FunctionDeclaration>) {\n        const node = path.node\n        const body = node.body\n        \n        if (!body || (body.body.length === 0 && (!body.directives || body.directives.length === 0))) {\n          return\n        }\n\n        let foundDirective = false\n        if (body.directives) {\n          for (const directive of body.directives) {\n            if ((directive as any).value.value === 'use ai') {\n              foundDirective = true\n              break\n            }\n          }\n        }\n\n        if (!foundDirective) {\n          return\n        }\n\n        const operation = handleUseAiFunction(\n          path,\n          pluginOptions as Required<PluginOptions>,\n          cache\n        )\n        pendingOperations.push(operation)\n      },\n    },\n    post() {\n      return Promise.all(pendingOperations)\n    },\n  }\n}\n\nfunction isUseAiDirective(statement: t.Statement): boolean {\n  if (!t.isExpressionStatement(statement)) {\n    return false\n  }\n\n  const expr = statement.expression\n  let stringLiteral: t.StringLiteral | null = null\n  \n  if (t.isStringLiteral(expr)) {\n    stringLiteral = expr\n  } else if (t.isTSAsExpression(expr) && t.isStringLiteral(expr.expression)) {\n    stringLiteral = expr.expression\n  }\n\n  if (!stringLiteral) {\n    return false\n  }\n\n  return stringLiteral.value === 'use ai'\n}\n\nfunction extractMetadataFromDirective(body: t.BlockStatement): Metadata {\n  if (!body || !body.directives || body.directives.length === 0) {\n    return {}\n  }\n\n  let useAiDirective: any = null\n  for (const directive of body.directives) {\n    if ((directive as any).value.value === 'use ai') {\n      useAiDirective = directive\n      break\n    }\n  }\n\n  if (!useAiDirective) {\n    return {}\n  }\n\n  const trailingComments = useAiDirective.trailingComments\n  if (!trailingComments || trailingComments.length === 0) {\n    return {}\n  }\n\n  const comment = trailingComments[0]\n  const commentText = comment.value.trim()\n  const metadata: Metadata = {}\n  const pairs = commentText.split(',').map((s: string) => s.trim())\n\n  for (const pair of pairs) {\n    const [key, value] = pair.split('=').map((s: string) => s.trim())\n    if (key === 'temperature' || key === 'seed') {\n      metadata[key as keyof Metadata] = isNaN(Number(value))\n        ? (value as any)\n        : parseFloat(value)\n    } else if (key === 'instructions') {\n      metadata.instructions = value.replace(/^[\"']|[\"']$/g, '')\n    } else if (key === 'model') {\n      metadata.model = value\n    }\n  }\n\n  return metadata\n}\n\nasync function handleUseAiFunction(\n  path: NodePath<t.FunctionDeclaration>,\n  pluginOptions: Required<PluginOptions>,\n  cache: FunctionCache\n): Promise<void> {\n  const node = path.node\n  const metadata = extractMetadataFromDirective(node.body)\n  \n  const sourceCode = path.getSource()\n  const signatureMatch = sourceCode.match(/^[^{]+/)\n  const functionSignature = signatureMatch ? signatureMatch[0].trim() : sourceCode\n  \n  const mergedMetadata: Metadata = {\n    ...metadata,\n    model: metadata.model || pluginOptions.model,\n    temperature: metadata.temperature ?? pluginOptions.temperature,\n  }\n\n  const prompt = buildPrompt(functionSignature, mergedMetadata)\n\n  try {\n    let generatedBody = await generateFunctionBody(\n      prompt,\n      mergedMetadata,\n      pluginOptions.apiKey,\n      cache,\n      functionSignature\n    )\n    \n    generatedBody = generatedBody.replace(/```(?:typescript|javascript|ts|js)?\\n?/g, '').replace(/```\\n?/g, '')\n\n    const bodyAst = parseBodyToAst(generatedBody)\n    node.body.body = bodyAst\n    node.body.directives = []\n  } catch (error) {\n    throw error\n  }\n}\n\nfunction parseBodyToAst(bodyString: string): t.Statement[] {\n  const parser = require('@babel/parser')\n\n  try {\n    const ast = parser.parse(`(function() { ${bodyString} })`, {\n      sourceType: 'module',\n      plugins: ['typescript'],\n    })\n\n    const functionExpr = ast.program.body[0].expression\n    const blockStatement = functionExpr.body\n\n    return blockStatement.body\n  } catch (error) {\n    throw error\n  }\n}\n"]}