{"version":3,"sources":["../src/cache.ts","../src/code-generator.ts","../src/prompt-builder.ts","../src/plugin.ts"],"names":["require","path"],"mappings":"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","file":"plugin.js","sourcesContent":["import crypto from \"node:crypto\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport type { Metadata } from \"./prompt-builder\";\n\nexport interface CacheEntry {\n\tsignature: string;\n\tmetadata: Metadata;\n\tgeneratedCode: string;\n\ttimestamp: number;\n}\n\nexport interface Cache {\n\t[key: string]: CacheEntry;\n}\n\nexport class FunctionCache {\n\tprivate cachePath: string;\n\tprivate cache: Cache;\n\n\tconstructor(cacheFilePath: string = \".ai-cache.json\") {\n\t\tthis.cachePath = path.resolve(process.cwd(), cacheFilePath);\n\t\tthis.cache = this.loadCache();\n\t}\n\n\tprivate loadCache(): Cache {\n\t\ttry {\n\t\t\tif (fs.existsSync(this.cachePath)) {\n\t\t\t\tconst data = fs.readFileSync(this.cachePath, \"utf-8\");\n\t\t\t\treturn JSON.parse(data);\n\t\t\t}\n\t\t} catch (_error) {}\n\t\treturn {};\n\t}\n\n\tprivate saveCache(): void {\n\t\ttry {\n\t\t\tfs.writeFileSync(\n\t\t\t\tthis.cachePath,\n\t\t\t\tJSON.stringify(this.cache, null, 2),\n\t\t\t\t\"utf-8\",\n\t\t\t);\n\t\t} catch (_error) {}\n\t}\n\n\tprivate generateKey(signature: string, metadata: Metadata): string {\n\t\tconst data = JSON.stringify({ signature, metadata });\n\t\treturn crypto.createHash(\"sha256\").update(data).digest(\"hex\");\n\t}\n\n\tget(signature: string, metadata: Metadata): string | null {\n\t\tconst key = this.generateKey(signature, metadata);\n\t\tconst entry = this.cache[key];\n\n\t\tif (entry) {\n\t\t\treturn entry.generatedCode;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tset(signature: string, metadata: Metadata, generatedCode: string): void {\n\t\tconst key = this.generateKey(signature, metadata);\n\t\tthis.cache[key] = {\n\t\t\tsignature,\n\t\t\tmetadata,\n\t\t\tgeneratedCode,\n\t\t\ttimestamp: Date.now(),\n\t\t};\n\t\tthis.saveCache();\n\t}\n\n\tclear(): void {\n\t\tthis.cache = {};\n\t\tthis.saveCache();\n\t}\n\n\tsize(): number {\n\t\treturn Object.keys(this.cache).length;\n\t}\n}\n","import { createOpenRouter } from \"@openrouter/ai-sdk-provider\";\nimport { generateText } from \"ai\";\nimport type { FunctionCache } from \"./cache\";\nimport type { Metadata } from \"./prompt-builder\";\n\nexport async function generateFunctionBody(\n\tprompt: string,\n\tmetadata: Metadata = {},\n\tapiKey?: string,\n\tcache?: FunctionCache,\n\tfunctionSignature?: string,\n): Promise<string> {\n\tif (cache && functionSignature) {\n\t\tconst cached = cache.get(functionSignature, metadata);\n\t\tif (cached) {\n\t\t\treturn cached;\n\t\t}\n\t}\n\n\tconst key = apiKey || process.env.OPENROUTER_API_KEY;\n\tif (!key) {\n\t\tthrow new Error(\"OpenRouter API key is required\");\n\t}\n\n\tconst openrouter = createOpenRouter({ apiKey: key });\n\tconst model = openrouter(metadata.model || \"openai/gpt-4-turbo\");\n\n\tconst options: Record<string, any> = {\n\t\ttemperature: metadata.temperature ?? 0.7,\n\t};\n\n\tif (metadata.seed !== undefined) {\n\t\toptions.seed = metadata.seed;\n\t}\n\tconst { text } = await generateText({\n\t\tmodel,\n\t\tprompt,\n\t\t...options,\n\t});\n\n\tconst generatedCode = text.trim();\n\n\tif (cache && functionSignature) {\n\t\tcache.set(functionSignature, metadata, generatedCode);\n\t}\n\n\treturn generatedCode;\n}\n","export interface Metadata {\n\ttemperature?: number;\n\tseed?: number;\n\tinstructions?: string;\n\tmodel?: string;\n}\n\nexport function buildPrompt(\n\tfunctionCode: string,\n\tmetadata: Metadata = {},\n): string {\n\tconst basePrompt = `You are a code generation assistant. Generate a function body for the following function:\n\n${functionCode}\n\nRequirements:\n- Implement the function according to its name and type signature\n- The function name describes what it should do\n- Must return the correct type\n- No side effects unless implied by the name\n- Valid TypeScript/JavaScript\n- No comments in the generated code\n- No console.log or debugging statements\n\n${metadata.instructions ? `Additional instructions: ${metadata.instructions}` : \"\"}\n\nGenerate ONLY the function body code (no outer braces, no function declaration).\nExample:\nfor (let i = 0; i < arr.length; i++) {\n  // code here\n}\nreturn result`;\n\n\treturn basePrompt;\n}\n\nexport function extractMetadata(leadingComments: any[] | undefined): Metadata {\n\tif (!leadingComments || leadingComments.length === 0) {\n\t\treturn {};\n\t}\n\n\tconst lastComment = leadingComments[leadingComments.length - 1];\n\tconst commentText = lastComment.value;\n\n\tconst metadataMatch = commentText.match(/@ai\\s+(.+)/);\n\tif (!metadataMatch) {\n\t\treturn {};\n\t}\n\n\tconst metadata: Metadata = {};\n\tconst pairs = metadataMatch[1].split(\",\").map((s: string) => s.trim());\n\n\tfor (const pair of pairs) {\n\t\tconst [key, value] = pair.split(\"=\").map((s: string) => s.trim());\n\t\tif (key === \"temperature\" || key === \"seed\") {\n\t\t\tmetadata[key as keyof Metadata] = Number.isNaN(Number(value))\n\t\t\t\t? (value as any)\n\t\t\t\t: parseFloat(value);\n\t\t} else if (key === \"instructions\") {\n\t\t\tmetadata.instructions = value.replace(/^[\"']|[\"']$/g, \"\");\n\t\t} else if (key === \"model\") {\n\t\t\tmetadata.model = value;\n\t\t}\n\t}\n\n\treturn metadata;\n}\n","import { createRequire } from \"node:module\";\nimport type { NodePath } from \"@babel/traverse\";\nimport * as t from \"@babel/types\";\nimport { FunctionCache } from \"./cache\";\nimport { generateFunctionBody } from \"./code-generator\";\nimport type { Metadata } from \"./prompt-builder\";\nimport { buildPrompt } from \"./prompt-builder\";\n\nconst require = createRequire(import.meta.url);\n\nexport interface PluginOptions {\n\tapiKey?: string;\n\tmodel?: string;\n\ttemperature?: number;\n}\n\nexport default function babelPluginUseAi(\n\t_babelApi: any,\n\toptions: PluginOptions = {},\n) {\n\tconst apiKey = options.apiKey || process.env.OPENROUTER_API_KEY;\n\tif (!apiKey) {\n\t\tthrow new Error(\n\t\t\t\"babel-plugin-use-ai: apiKey is required. Pass it via options or set OPENROUTER_API_KEY environment variable.\",\n\t\t);\n\t}\n\n\tconst pluginOptions = {\n\t\tapiKey,\n\t\tmodel: options.model || \"openai/gpt-4-turbo\",\n\t\ttemperature: options.temperature ?? 0.7,\n\t};\n\n\tconst cache = new FunctionCache();\n\tconst pendingOperations: Promise<void>[] = [];\n\n\treturn {\n\t\tname: \"babel-plugin-use-ai\",\n\t\tvisitor: {\n\t\t\tFunctionDeclaration(path: NodePath<t.FunctionDeclaration>) {\n\t\t\t\tconst node = path.node;\n\t\t\t\tconst body = node.body;\n\n\t\t\t\tif (\n\t\t\t\t\t!body ||\n\t\t\t\t\t(body.body.length === 0 &&\n\t\t\t\t\t\t(!body.directives || body.directives.length === 0))\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet foundDirective = false;\n\t\t\t\tif (body.directives) {\n\t\t\t\t\tfor (const directive of body.directives) {\n\t\t\t\t\t\tif ((directive as any).value.value === \"use ai\") {\n\t\t\t\t\t\t\tfoundDirective = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!foundDirective) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst operation = handleUseAiFunction(\n\t\t\t\t\tpath,\n\t\t\t\t\tpluginOptions as Required<PluginOptions>,\n\t\t\t\t\tcache,\n\t\t\t\t);\n\t\t\t\tpendingOperations.push(operation);\n\t\t\t},\n\t\t},\n\t\tpost() {\n\t\t\treturn Promise.all(pendingOperations);\n\t\t},\n\t};\n}\n\nfunction _isUseAiDirective(statement: t.Statement): boolean {\n\tif (!t.isExpressionStatement(statement)) {\n\t\treturn false;\n\t}\n\n\tconst expr = statement.expression;\n\tlet stringLiteral: t.StringLiteral | null = null;\n\n\tif (t.isStringLiteral(expr)) {\n\t\tstringLiteral = expr;\n\t} else if (t.isTSAsExpression(expr) && t.isStringLiteral(expr.expression)) {\n\t\tstringLiteral = expr.expression;\n\t}\n\n\tif (!stringLiteral) {\n\t\treturn false;\n\t}\n\n\treturn stringLiteral.value === \"use ai\";\n}\n\nfunction extractMetadataFromDirective(body: t.BlockStatement): Metadata {\n\tif (!body || !body.body || body.body.length === 0) {\n\t\treturn {};\n\t}\n\n\tconst firstStatement = body.body[0];\n\tif (!firstStatement || !firstStatement.leadingComments) {\n\t\treturn {};\n\t}\n\n\tconst metadata: Metadata = {};\n\n\tfor (const comment of firstStatement.leadingComments) {\n\t\tconst commentText = comment.value.trim();\n\t\tconst match = commentText.match(/^\\s*(\\w+)\\s*=\\s*(.+)$/);\n\n\t\tif (!match) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [, key, rawValue] = match;\n\t\tconst value = rawValue.trim().replace(/^[\"']|[\"']$/g, \"\");\n\n\t\tif (key === \"temperature\" || key === \"seed\") {\n\t\t\tmetadata[key as keyof Metadata] = Number.isNaN(Number(value))\n\t\t\t\t? (value as any)\n\t\t\t\t: parseFloat(value);\n\t\t} else if (key === \"instructions\") {\n\t\t\tmetadata.instructions = value;\n\t\t} else if (key === \"model\") {\n\t\t\tmetadata.model = value;\n\t\t}\n\t}\n\n\treturn metadata;\n}\n\nasync function handleUseAiFunction(\n\tpath: NodePath<t.FunctionDeclaration>,\n\tpluginOptions: Required<PluginOptions>,\n\tcache: FunctionCache,\n): Promise<void> {\n\tconst node = path.node;\n\tconst metadata = extractMetadataFromDirective(node.body);\n\n\tconst sourceCode = path.getSource();\n\tconst signatureMatch = sourceCode.match(/^[^{]+/);\n\tconst functionSignature = signatureMatch\n\t\t? signatureMatch[0].trim()\n\t\t: sourceCode;\n\n\tconst mergedMetadata: Metadata = {\n\t\t...metadata,\n\t\tmodel: metadata.model || pluginOptions.model,\n\t\ttemperature: metadata.temperature ?? pluginOptions.temperature,\n\t};\n\n\tconst prompt = buildPrompt(functionSignature, mergedMetadata);\n\tlet generatedBody = await generateFunctionBody(\n\t\tprompt,\n\t\tmergedMetadata,\n\t\tpluginOptions.apiKey,\n\t\tcache,\n\t\tfunctionSignature,\n\t);\n\n\tgeneratedBody = generatedBody\n\t\t.replace(/```(?:typescript|javascript|ts|js)?\\n?/g, \"\")\n\t\t.replace(/```\\n?/g, \"\");\n\n\tconst bodyAst = parseBodyToAst(generatedBody);\n\tnode.body.body = bodyAst;\n\tnode.body.directives = [];\n}\n\nfunction parseBodyToAst(bodyString: string): t.Statement[] {\n\tconst parser = require(\"@babel/parser\");\n\tconst ast = parser.parse(`(function() { ${bodyString} })`, {\n\t\tsourceType: \"module\",\n\t\tplugins: [\"typescript\"],\n\t});\n\n\tconst functionExpr = ast.program.body[0].expression;\n\tconst blockStatement = functionExpr.body;\n\n\treturn blockStatement.body;\n}\n"]}